### 函数柯里化
简单理解：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数    

将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。
- 参数复用
- 提前返回
- 延迟执行
```
// 普通函数
function fn(a,b,c,d){
    console.log(a,b,c,d,e)
}
// 生成的柯里化函数
let _fn = curry(fn)

_fn(1,2)
_fn(1,2)(3)
```
- 已经柯里化的函数，接收的参数数量与原函数的形参数量相同时，执行原函数
- 当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直到接收的参数数量与原函数的形参数量一致，执行原函数  
柯里化后函数拥有了更加多的自由  
正则校验
```
function checkByRegExp(regExp, string){
    return regExp.test(string)
}
checkByExp(/^1\d{10}$/, '18642838455') // 校验电话号码
checkByExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com') // 校验邮箱
```
如果要校验多个邮箱或者多个电话，需要校验多次  
优化——参数复用
```
let _check = curry(checkByRegExp)
// 生成工具函数
let checkCellPhone = _check(/^1\d{10}$/)
let checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/)
checkCellPhone('18642838455') // 校验电话号码
checkCellPhone('13109840560') // 校验电话号码

checkEmail('test@163.com')
```
#### 封装柯里化函数
- 判断当前函数传入的参数是否大于或等于fn需要的参数的数量，如果是，直接执行fn
- 如果传入的参数不够，返回一个闭包，暂存传入的参数，并重新返回curry函数
```
function curry(fn, args){
    const len = fn.length
    const args = args || []
    return function(){
        const _args = [].slice.call(arguments)
        [].push.apply(_args, args)
        if(_args.length < args.length){
            return curry.call(this, fn, _args)
        }
        return fn.apply(this, _args)
    }
}
function fun(a,b,c){
    console.log(a,b,c)
}
const curFun = curry(fun)

```

#### 求和
```
functon adds(a,b,c){
    return a+b+c
}
function currying(fn, len){
    len = len || fn.length
    return function(){
        var args = [].slice.call(arguments)
        if(args.length < len){
            return currying(fn.bind(this, ...args), len - args.length)
        }else {
            return fn.call(this, ...args)
        }
    }
}
```
> 实现
add(1) // 1  
add(1)(2);  // 3  
add(1)(2)(3)// 6  
add(1)(2)(3)(4) // 10   

```
function add(){
    let data = [].concat(Array.prototype.slice.call(arguments))
    function tmp(){
        data = data.concat([].concat(Array.prototype.slice.call(arguments)))
        return tmp
    }
    tmp.valueOf = function(){
        return data.reduce((pre, cur) => pre + cur, 0)
    }
    tmp.toString = function(){
        return data.reduce((pre, cur) => pre + cur, 0)
    }
    return tmp
}
```