### 防抖(debounce)
防抖：不管事件触发频率多高，一定在事件触发n秒后才执行，如果一个事件触发的n秒内又触发了这个事件，就以新的事件的事件为准，n秒后才执行，总之，触发事件的n秒内不再触发事件，n秒后再执行。  

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。  

- 窗口大小变化，调整样式
```
window.addEventListener('resize', debounce(handleResize, 20))
```
- 搜索框。输入完成后1000毫秒搜索
```
debounce(fetchSelectData, 300)
```
- 表单验证，输入1000毫秒后验证
```
debounce(validator, 1000)
```

- flag表示第一次是否立即执行
```
function debounce(fn, time, flag){
    let timer = null
    return function(...args){
        clearTimeout(timer)
        if(flag && !timer){
            fn.apply(this, args)
        }
        time = setTimeout(() => {
            fn.apply(this, args)
        }, time)
    }
}
```
### 节流
节流：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴  
- 懒加载要监听滚动条的位置，使用节流按照一定的时间获取
- 用户点击提交按钮，如果直到接口大致返回的时间，使用节流，在一段时间内只允许点击一次
```
function throttle(fn, time){
    let timer = null
    let pre = 0
    return function(...args){
        if(Data.now() - pre > time){
            clearTimeout(timer)
            timer = null
            pre = Date.now()
            fn.apply(this, args)
        }else if(!timer){
            timer = setTimeout(() => {
                fn.apply(this, args)
            }, time)
        }
    }
}
```

函数防抖：将几次操作合并为一次操作进行，原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再触发的话，就会取消之前的计时器重新设置，这样一来，只有在最后一次操作才能被触发  

函数节流：使得在一定时间内只触发一次函数，原理是通过判断是否到达一定时间来触发函数   

区别：函数节流不管触发的多频繁，都会保证在规定的时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数
