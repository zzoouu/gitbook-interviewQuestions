### 箭头函数
> 使用 => 定义的函数  

#### 箭头函数的特点
1. 更短的语法
- 没有参数时，用一个括号代表参数部分，一个参数时，可省略括号
- 代码块部分只有一条语句时，可以省略大括号和return
- 如果只返回一个对象，需要将对象用括号包起来，因为大括号会被解释为代码块
2. 不能通过new关键字调用
箭头函数不能用作构造函数
```
let F = ()=>{};
// 报错 TypeError: F is not a constructor
let f = new F();
```
3. 没有原型
不能用new关键字调用，所以没有构造原型的需求,所以箭头函数没有prototype这个属性
```
let F = ()=>{};
console.log(F.prototype) // undefined
```
4. 不能用作Generator函数
在箭头函数中，不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
5. 没有arguments、super、new.target
这些值箭头函数本身没有，由箭头函数外部最近一层非箭头函数决定
```
let f = ()=>console.log(arguments);
//报错
f(); // arguments is not defined
```
由于在全局环境下，定义箭头函数 f，对于 f 来说，无法获取到外围非箭头函数的 arguments 值，所以此处报错。
```
function fn(){
    let f = ()=> console.log(arguments)
    f();
}
fn(1,2,3) // [1,2,3]
```
箭头函数 f 内部的 arguments，其实是函数 fn 的 arguments 变量。  
若想在箭头函数中获取不定长度的参数列表，可以使用 ES6 中的 rest 参数解决：
```
let f = (...args) => console.log(args)
f(1,2,3,4,5) // [1,2,3,4,5]
```
6. 没有this绑定
> 箭头函数体内的 this 对象就是定义时所在的对象，而不是使用时所在的对象。  

- 箭头函数的外层如果有普通函数，那么箭头函数的 this 就是外层普通函数的this
- 箭头函数的外层如果没有普通函数，那么箭头函数的 this 就是全局变量
*箭头函数的 this 与外层的第一个普通函数的 this 相等，与嵌套了几层箭头函数无关。*
```
let obj = {
    fn:function(){
        console.log('我是普通函数',this === obj)
        return ()=>{
            console.log('我是箭头函数',this === obj)
        }
    }
}
console.log(obj.fn()())
// 我是普通函数 true
// 我是箭头函数 true
let obj = {
    fn:()=>{
        console.log(this === window);
    }
}
console.log(obj.fn()) // true
```
7. 箭头函数+call、apply、bind
call 和 apply 的作用是改变函数 this 的指向，传递参数，并将函数执行， 而 bind 的作用是生成一个绑定 this 并预设函数参数的新函数  
然而由于箭头函数根本没有自己的 this ，所以：
- 当对箭头函数使用 call 或 apply 方法时，只会传入参数并调用函数，并不会改变箭头函数中 this 的指向；
- 当对箭头函数使用 bind 方法时，只会返回一个预设参数的新函数，并不会绑定新函数的 this 指向。
```
window.name = 'window_name';
let f1 = function(){return this.name}
let f2 = ()=> this.name
let obj = {name:'obj_name'}
f1.call(obj) // obj_name
f2.call(obj) // window_name
```
箭头函数的 this 指向在其定义时就已确定，永远不会发生改变，所以在对 f2 使用 call、apply、bind 时，会忽略传入的上下文参数。

#### 箭头函数题目
##### 题目一
```
function foo(n) {
  var f = () => arguments[0] + n;
  return f();
}
let res = foo(2);
console.log(res); // 问 输出结果
```
结果： 4
解析：箭头函数没有自己arguments，有外部第一个非箭头函数决定，即为foo的arguments，arguments=[2],n=2
##### 题目二
```
function A() {
  this.foo = 1
}
A.prototype.bar = () => console.log(this.foo)

let a = new A()
a.bar() // 问 输出结果
```
结果：undefined
解析：箭头函数的this在定义时决定，外层没有普通函数，则为全局变量全局中无foo,window中无foo，输出undefined
##### 题目三
```
let res = (function pt() {
  return (() => this.x).bind({ x: 'inner' })();
}).call({ x: 'outer' });
console.log(res)
```
结果：outer
解析：
1. 求函数 pt 通过 call 调用后的返回值。
2. pt 函数内的 this 被 call 转换为 {x:'outer'}。
3. pt 函数内，箭头函数通过 bind 生成了新函数，并执行，执行结果为 pt 函数的返回值。
4. 箭头函数中的 this 无法通过 bind 方法绑定，箭头函数执行时的 this 就是外层作用域的 this。
5. 箭头函数执行时，外层作用域的 this 是由 call 方法指定的 {x:'outer'}。
6. 最终结果 res 为 'outer'。

##### 题目四
```
window.name = 'window_name';
let obj1 = {
    name:'obj1_name',
    print:()=>console.log(this.name)
}
let obj2 = {name:'obj2_name'}

obj1.print()  // 问 输出结果
obj1.print.call(obj2)  // 问 输出结果
```
结果：window_name，window_name
解析：箭头函数没有自己的 this ，也无法通过 call、apply、bind 改变箭头函数中的 this。
箭头函数的 this 取决于外层是否有普通函数，有普通函数 this 指向普通函数中的this，外层没有普通函数，箭头函数中的 this 就是全局对象
此题中，箭头函数外层没有普通函数，所以 this 指向全局对象，所以结果为 'window_name'、'window_name'
##### 题目五
```
let obj1 = {
    name:'obj1_name',
    print:function(){
        return ()=>console.log(this.name)
    }
}
let obj2 = {name:'obj2_name'}
obj1.print()() // 问 输出结果
obj1.print().call(obj2) // 问 输出结果
obj1.print.call(obj2)()
```
结果：'obj1_name'，'obj1_name'，'obj2_name'
解析：obj1.print 返回一个箭头函数，此箭头函数中的 this 就是 obj1.print 调用时的 this。
obj1.print()()：此时obj1.print 中的 this 为 obj1，所以输出为 obj1_name
obj1.print().call(obj2)：此时obj1.print 中的 this 为 obj1，所以输出为 obj1_name
obj1.print.call(obj2)()：此时obj1.print 中的 this 为 obj2，所以输出为 obj2_name
> obj1.print => function(){return ()=>console.log(this.name)}

> obj1.print() => ()=>console.log(this.name)
