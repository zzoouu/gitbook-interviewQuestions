### 深浅拷贝
深浅拷贝都是对于引用数据类型而言
#### 浅拷贝
浅拷贝的意思就是只复制引用，而未复制真正的值
1. Object.assign
Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。
```
var obj = { a: {a: "kobe", b: 39} };
var initalObj = Object.assign({}, obj);
initalObj.a.a = "wade";
console.log(obj.a.a); //wade
```
*当obj只有一层时，是深拷贝*
```
let obj = {
   username: 'kobe'
   };
let obj2 = Object.assign({},obj);
obj2.username = 'wade';
console.log(obj);//{username: "kobe"}
```

2. Array.prototype.concat()
```
let arr = [1, 3, {
   username: 'kobe'
   }];
let arr2=arr.concat();    
arr2[2].username = 'wade';
console.log(arr)
```
修改新对象会改到原对象

3. Array.prototype.slice()
```
let arr = [1, 3, {
   username: ' kobe'
   }];
let arr3 = arr.slice();
arr3[2].username = 'wade'
console.log(arr);
```
同样修改新对象会改到原对象：
关于Array的slice和concat方法的补充说明：  
Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。  
原数组的元素会按照下述规则拷贝：
如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。  
对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 
4. ES6扩展运算符
```
let {...b} = a; let [...b] = a; 
```
当object只有一层的时候，是深拷贝

#### 深拷贝
深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了
1. JSON.parse(JSON.stringify())
```
 let arr = [1, 3, {
   username: ' kobe'
}];
let arr4 = JSON.parse(JSON.stringify(arr));
arr4[2].username = 'duncan'; 
console.log(arr, arr4)
```
原理：用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝  

- 函数无法拷贝(拷贝后为null),如果被拷贝的对象中有function，则拷贝之后的对象就会丢失这个function
- 原型链上的属性无法拷贝  
- 不能正确的处理 Date 类型的数据  
- 不能处理 RegExp,如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object
- 会忽略 symbol undefined  
```
let a = {name: 'liyanfeng', sayName: function() {alert(this.name)}, numberReg: /\d+/}
let b = JSON.parse(JSON.stringify(a))
// sayName丢失，numberReg变为了对象
console.dir(b) // {name: 'liyanfeng', numberReg: {}} 
```
2. 手写递归方法
递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。  
```
function getType(value){
    return Object.prototype.toString.call(value).slice(8, -1)
}
function _clone(target){
    let result
    let type = getType(target)
    if(type === 'Object'){
        result = {}
    }else if(type === 'Array'){
        result = []
    }else {
        result = target
        return
    }
    for(let i in target){
        let value = target[i]
        if(getType(value) === 'Object' || getType(value) === 'Array'){
            result[i] = _clone(value)
        }else {
            result[i] = value
        }
    }
    return result
}
```

```
function deepCopy(target){
    const type = typeof target
    if(typeof target !== 'object' || target === null) return target
    var ret = target instanceof Array ? [] : {}
    for(let key in target){
        if(target.hasOwnProperty(key)){
            ret[key] = (typeof target[key] !== 'object' || typeof target[key] === null) ? target[key] : deepCopy(target[key])
        }
    }
    return ret
}
```
3. Array.from
// 数组的深拷贝
Array.from 实现数组的克隆  // arguments dom
```  
function deepClone(arr){
 return Array.isArray(arr) ? Array.from(arr, deepClone) : arr
}
var a = [[1,2,3], [3,4]]
var b = deepClone(a) // [[1,2,3], [3,4]]
b === a // false
b[0] // [1,2,3]
a[0] // [1,2,3]
b[0] = [1,2]
a[0] // [1,2,3]
```