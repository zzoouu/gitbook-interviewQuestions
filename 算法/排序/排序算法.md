### 排序算法
https://juejin.im/post/5d341a89f265da1bac405369#heading-5
> 排序算法：执行效率、内存消耗、稳定性
#### 复杂度：
- 时间复杂度：一个算法执行所消耗的时间
- 空间复杂度： 运行完一个程序所需内存的大小
#### 复杂度分析
##### 时间复杂度
1. 大O表示法：  
算法的执行时间与每行代码的执行次数成正比，用 T(n) = O(f(n)) 表示  
- T(n) 表示算法执行总时间  
- f(n) 表示每行代码执行总次数  
- n 往往表示数据的规模。  
这就是大 O 时间复杂度表示法。

2. 时间复杂度
> 算法的时间复杂度，也就是算法的时间量度。  
大 O 时间复杂度表示法 实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫渐进时间复杂度，简称时间复杂度
例子1
```
function aFun() {
    console.log("Hello, World!");      //  需要执行 1 次
    return 0;       // 需要执行 1 次
}
```
这个方法需要执行 2 次运算

例子2
```
function bFun(n) {
    for(let i = 0; i < n; i++) {         // 需要执行 (n + 1) 次
        console.log("Hello, World!");      // 需要执行 n 次
    }
    return 0;       // 需要执行 1 次
}
```
这个方法需要执行 ( n + 1 + n + 1 ) = 2n +2 次运算

例子3
```
function cal(n) {
   let sum = 0; // 1 次
   let i = 1; // 1 次
   let j = 1; // 1 次
   for (; i <= n; ++i) {  // n 次
     j = 1;  // n 次
     for (; j <= n; ++j) {  // n * n ，也即是  n平方次
       sum = sum +  i * j;  // n * n ，也即是  n平方次
     }
   }
 }
```
这里是二层 for 循环，所以第二层执行的是 n * n = n2 次，而且这里的循环是 ++i，和例子 2 的是 i++，是不同的，是先加与后加的区别。  
这个方法需要执行 ( n2 + n2 + n + n + 1 + 1 +1 ) = 2n2 +2n + 3 

以时间复杂度为例，由于 时间复杂度 描述的是算法执行时间与数据规模的 增长变化趋势，所以 常量、低阶、系数 实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时 忽略 这些项。
所以，上面例子1 的时间复杂度为 T(n) = O(1)，例子2 的时间复杂度为 T(n) = O(n)，例子3 的时间复杂度为 T(n) = O(n2)

3. 时间复杂度分析
31. 只关注循环执行次数最多的一段代码
```
function cal(n) { 
   let sum = 0;
   let i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```
执行次数最多的是 for 循环及里面的代码，执行了 n 次，所以时间复杂度为 O(n)。
32. 加法法则：总复杂度等于量级最大的那段代码的复杂度  
多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度
```
function cal(n) {
   let sum_1 = 0;
   let p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   let sum_2 = 0;
   let q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   let sum_3 = 0;
   let i = 1;
   let j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```
上面代码分为三部分，分别求 sum_1、sum_2、sum_3 ，主要看循环部分。  
第一部分，求 sum_1 ，明确知道执行了 100 次，而和 n 的规模无关，是个常量的执行时间，不能反映增长变化趋势，所以时间复杂度为 O(1)。  
第二和第三部分，求 sum_2 和 sum_3 ，时间复杂度是和 n 的规模有关的，为别为 O(n) 和 O(n2)。  
所以，取三段代码的最大量级，上面例子的最终的时间复杂度为 O(n2)。  
同理类推，如果有 3 层 for 循环，那么时间复杂度为 O(n3)，4 层就是  O(n4)。  
33. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积  
嵌套代码求乘积：比如递归、多重循环等  
```
function cal(n) {
   let ret = 0; 
   let i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i); // 重点为  f(i)
   } 
 } 
 
function f(n) {
  let sum = 0;
  let i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```
方法 cal 循环里面调用 f 方法，而 f 方法里面也有循环。  
所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2) 。  
34. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加
```
function cal(m, n) {
  let sum_1 = 0;
  let i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  let sum_2 = 0;
  let j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```
以上代码也是求和 ，求 sum_1 的数据规模为 m、求 sum_2 的数据规模为 n，所以时间复杂度为 O(m+n)。
35. 多个规模求乘法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘
```
function cal(m, n) {
  let sum_3 = 0;
   let i = 1;
   let j = 1;
   for (; i <= m; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
}
```
以上代码也是求和，两层 for 循环 ，求 sum_3 的数据规模为 m 和 n，所以时间复杂度为 O(m*n)。

4. 常用的时间复杂度分析
41. 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n2) （平方阶）、O(n3)（立方阶)

下面举例说明 O(logn)（对数阶）：
```
let i=1;
while (i <= n)  {
   i = i * 2;
}
```
代码是从 1 开始，每次循环就乘以 2，当大于 n 时，循环结束。  
其实就是高中学过的等比数列，i 的取值就是一个等比数列。在数学里面是这样子的：  
20  21  22  ... 2k ...  2x  = n  
所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了，通过 2x = n 求解 x，数学中求解得 x = log2n 。所以上面代码的时间复杂度为 O(log2n)。  
实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？  
因为对数之间是可以互相转换的，log3n = log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。  
> 在对数阶时间复杂度的表示方法里，我们忽略对数的 “底”，统一表示为 O(logn)  
42. 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差  
包括 O(2n)（指数阶）、O(n!)（阶乘阶）
```
aFunc( n ) {
    if (n <= 1) {
        return 1;
    } else {
        return aFunc(n - 1) + aFunc(n - 2);
    }
}
```
5. 常见时间复杂度总结
常用的时间复杂度所耗费的时间从小到大依次是：  w
O(1) < O(logn) < (n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)

##### 空间复杂度
空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系 。  
算法的空间复杂度通过计算算法所需的存储空间实现  
算法的空间复杂度的计算公式记作：S(n) = O(f(n))  
- n 为问题的规模  
- f(n) 为语句关于 n 所占存储空间的函数。
```
function print(n) {
 const newArr = []; // 第 2 行
 newArr.length = n; // 第 3 行
  for (let i = 0; i <n; ++i) {
    newArr[i] = i * i;
  }

  for (let j = n-1; j >= 0; --j) {
    console.log(newArr[i])
  }
}
```
跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 newArr ，是个空数组。第 3 行把 newArr 的长度修改为 n 的长度的数组，每项的值为 undefined ，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。
