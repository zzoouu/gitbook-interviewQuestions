### 动态规划
三要点：
- 最优子结构
- 边界
- 状态转移公式
大事化小，小事化了  
将原问题划分为更简单的子问题
#### 放书问题
> 一个书架只能放10本书，一次只能放一本或者两本，问有多少种算法

思路： 
- 当放书只剩下一步就可以将书架放满时，有两种放法：已经放了八本，已经放了九本；F(10)=F(9)+F(8)
- 引申：0到8本有多少种放法，0到9有多少种放法：F(8)=F(7)+F(6);F(9)=F(8)+F(7)……
- F(1)=1;F(2)=2;F(n)=F(n-1)+F(n-2)(n>=3)
最优子结构：F(10)=F(9)+F(8)，F(8)和F(9)就是最优子结构    
边界：F(1)和F(2)  
状态转移公式：F(n)=F(n-1)+F(n-2)(n>=3)  
#### 实战——leetcode：63
> 一个机器人位于一个m*n网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。说明：m和n的值均不超过 100。
> 输入: [[0,0,0],[0,1,0],[0,0,0] ]   
输出: 2   
解释:
3x3 网格的正中间有一个障碍物。   
从左上角到右下角一共有 2 条不同的路径：   
1. 向右 -> 向右 -> 向下 -> 向下   
2. 向下 -> 向下 -> 向右 -> 向右  

m:7,n:3  
最优子结构：F(7*3)的最优子结构——F(7*2)和F(6*3)  
边界：F(1*2)和F(2*1)  
状态转移公式： F(m*n)=F((m-1)*n)+F(m*(n-1))  
最终会拆分为一行或一列的情况，若一行中或一列中有障碍物就无法通过
#### 初步代码——递归
```
function deep(arr){
    dp = (m, n) => {
        // 起始位置或者目标位置有障碍物(1)，直接返回0，无法到达
        if(arr[m-1][n-1] === 1 || arr[0][0] === 1) return 0 
        if(m <2 || n <2){
            // 一行或一列
            if(m <2){
                // 一行
                return arr[m-1].includes(1) ? 0 : 1
            }else if(n < 2){
                // 一列
                let ret = 1
                arr.forEach((item) => {
                    item.forEach((inner,index) => {
                        if(index === 1){
                            ret = 0
                        }
                    })
                }) 
                return ret
            }
        }else {
            return dp(m-1, n) + dp(m, n-1)
        }
    }
    return dp(arr.legnth, arr[0].length)
}
```
时间复杂度：2^n
#### 优化
自底向下
```
arr => {
    let m = arr.length
    !m && return 0
    let n = arr[0].length
    let tmp = []
    if(arr[0][0] === 1 || arr[m-1][n-1] === 1){
        return 0
    }
    for(let i = 0;i<m; i++){
        tmp[i] = []
        for(let j = 0; j< n;j++){
            if(arr[i][j] === 1){
                return 0
            }else if(i === 0){
                tmp[i][j] = tmp[i][j-1] === 1 ? 0 : 1
            }else if(j === 0){
                tmp[i][j] = tmp[i-1][j] === 1 ? 0 : 1
            }else {
                return tmp[i-1][j] + tmp[i][j-1]
            }
        }
    }
    return tmp[n-1][m-1]
}
```
### 最大子序列和
给定一个整数数组，找到一个具有最大和的连续子数组，返回其最大和



### 背包问题








《js版数据结构与算法》
《漫画算法》