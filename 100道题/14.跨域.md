### 跨域(cross-origin)
> 跨域问题的出现  

浏览器有同源限制，会拒绝跨域请求
但并不是拒绝所有的跨域请求，实际拒绝的是跨域的读操作  
同源限制策略，浏览器：
- 允许跨域写操作,如链接，重定向
- 允许跨域资源嵌入，如img,script
- 不允许跨域读操作

> 跨域，非同源

同源：协议、端口、域名三者相同
> 跨域需求

一个项目有不同的职责，分散在不同的服务器上，对应不同的服务，需要调用不同的接口，需要跨域

### 跨域的方法
#### jsonp
原理：利用script标签没有同源限制的优势（上文的跨域资源嵌入），通过在script的scr中插入带有callback参数的get请求，服务端将接口数据拼凑到callback函数中返回给浏览器，浏览器解析执行，从而拿到callback函数返回的数据，前后端配合
1、原生js
```
const script = document.createElement('script')
script.type = 'text/javascript'
script.src = 'http://www.domain.com?callback=handleCallback'
document.head.appendChild(script)
function handleCallback(res){
    ....
}
```
2、jquery ajax
```
$.ajax({
    url: 'http://www.domain.com',
    type: 'get',
    dataType: 'jsonp',
    jsonpCallback: 'handleCallback'
    data: {}
})
```
3、vue axios
```
this.$http = axios
this.$http.jsonp('http://www.domain.com',{
    params: {},
    jsonp 'handlecallback'
}).then(res => ...)
```

node
```
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();

server.on('request', function(req, res) {
    var params = querystring.parse(req.url.split('?')[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```
> 缺点：只能发送get请求，XMLHttpRequest错误处理机制更好 优点：兼容性好

#### CORS(跨域资源共享)
cross-origin-resource-sharing:允许浏览器向跨域服务器发送XMLHttpRequest请求，客服ajax只能同源使用的缺点，需要浏览器和服务端同时支持
> 跨域请求：简单请求，非简单请求
##### 简单请求：同时满足以下两个条件
- 使用的方法为：get | post | head
- 请求的header是：Accept Accept-Language Content-Language Content-Type: application/x-www-form-urlencoded | multipart/formata | text/plain

简单请求，浏览器会直接发出cors请求，就是在头信息中增加一个origin字段，指明请求的协议域名端口（源），服务器据此决定是否同意请求

> cors请求设置的响应头字段都以Access-Control-开头  

1）Access-Control-Allow-Origin：必选  
它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 

2）Access-Control-Allow-Credentials：可选  
它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。    

3）Access-Control-Expose-Headers：可选  
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。

##### 非简单请求
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）

> 预检请求

预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，"预检"请求的头信息包括两个特殊字段。  
1）Access-Control-Request-Method：必选  
用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。  
2）Access-Control-Request-Headers：可选  
该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。
> 预检请求的回应

服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。
HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：  
1）Access-Control-Allow-Methods：必选  
它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。  
2）Access-Control-Allow-Headers    
如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。  
3）Access-Control-Allow-Credentials：可选  
该字段与简单请求时的含义相同。  
4）Access-Control-Max-Age：可选  
用来指定本次预检请求的有效期，单位为秒。
1、原生ajax
```
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
````
2、 node
```
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```
### postMessage
window.postMessage(data,targetOrigin)  
是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
```
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

