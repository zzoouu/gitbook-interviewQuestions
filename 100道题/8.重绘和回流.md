### 重绘和回流（重排）
#### 浏览器渲染过程
1. 解析html，生成dom树，解析css，生成cssom树
2. 将dom树和cssom树结合，生成渲染树render tree
3. layout(回流)，根据生成的渲染树，进行回流（layout），得到节点的几何信息（位置，大小）
4. painting（重绘），根据渲染树及回流得到的几何信息，得到节点的绝对像素
5. display:将像素发送给GPU,展示在页面上

#### 生成渲染树
1. 从dom的根节点开始遍历每个可见节点
2. 对于每个可见的节点，找到cssom树中对应的规则，并应用他们
3. 根据每个可见的节点以及其对应的样式，生成渲染树

> 不可见的节点
- 不会渲染输出的节点：script,link,meta
- 通过css隐藏的节点，比如:display: none,利用opacity和visibility隐藏的节点，还是会显示在渲染树中，只有display:none的节点才不会显示在渲染树上
*渲染树只包括可见节点*

#### 回流
得到了渲染树，还需要计算他们在设备视口（viewport)内的确切位置和大小，这个计算的阶段就是回流

#### 重绘
通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，就可以将渲染树的每个节点转化为屏幕上的实际像素，这个阶段就是重绘节点

#### 触发重绘和回流
回流主要是计算节点的位置和几何信息，当页面布局和几何信息发生变化的时候，就会发生回流
- 删除或添加可见的dom节点
- 元素的位置发生变化
- 元素的尺寸发生变化（边距、边框、高度等）
- 页面一开始渲染的时候
- 浏览器的视口发生变化的时候（因为回流就是根据视口的大小来计算元素的位置和大小的）
- 内容发生变化，文本或图片被另一大小的图片替换了
*回流一定会触发重绘，但重绘不一定会触发回流*

#### 浏览器的优化机制
回流会造成额外的计算消耗，大多数浏览器会通过队列化来批量执行回流过程，浏览器会将修改放在队列里，知道过了一段时间或者操作达到了阈值，才清空队列。但是，获取布局信息的操作会强制刷新队列
- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedtyle()
- getBoundingClientRect
以上属性和方法需要返回最新的布局信息，就会造成回流和重绘，来获取最新的信息，所以修改样式的时候，尽力避免使用上面的属性，如果使用，可以先将值存起来

#### 减少重绘和回流
##### 最下化重绘和回流
减少发生次数，可以合并多次对dom和样式的修改，然后一次处理
1. css操作
```
var el = document.getElementById('test')
el.style.paddingTop = '12px'
el.style.paddingLeft = '20px'
el.style.marginBottom = '10px'
```
以上操作会造成三次回流，可以将其合并处理
- cssText
```
el.style.cssText += 'padding-top: 12px;margin-bottom:10px;padding-top:12px;'
```
- class
```
el.className += 'active'
```
2. dom操作修改
减少重绘次数：
1. 使元素脱离文档流
2. 对元素进行多次修改
3. 将元素待会文档流

脱离文档流：
- 隐藏元素，应用修改，重新显示
- 使用文档片段(document ragment)在当前dom外构建一个子树，再把它拷贝回文档
- 将原始原素拷贝到脱离文档流的节点，修改节点后，再替换原始的元素

> 批量插入一段节点
```
function appendDataToElement(appendToElement, data){
    let li 
    for(let i = 0; i<data.length; i++){
        li = document.createElement('li)
        li.textContent = 'content'
        appendToElement.appendChild('list)
    }
}
const ul = document.getElementById('list')
appendDataToElement(ul, data)
```
每次循环都会插入一个新的节点，导致浏览器回流一次
1. 隐藏元素，应用修改，重新显示
```
ul.style.display = 'none'
appendToElement(ul, data)
ul.style.display = 'block'
```
2. 使用文档片段
```
const fragment = document.createDocumentFragment()
appendDataToElement(fragment, data)
ul.appendChild(fragment)
```
3. 拷贝到脱离文档流的节点中
```
const clone = ul.cloneNode(true)
appendDataToElement(clone, data)
ul.parentNode.replaceChild(clone, ul)
```
3. 避免触发同步布局事件
访问元素的属性的时候，浏览器可能回强制清空队列，强制同步布局，可以讲这个值先存起来
```
const w = box.offsetWidth
function ini(){
    for(let i = 0;i<100;i++){
        box.style.width = w + 'px'
    }
}
```

4. 复杂动画，使用绝对定位，脱离文档流，减少回流

### 常见减少回流和重绘的操作
1. css
- 使用transform代替top
- 使用visibility代替display：none，前者只会引起重绘，而后者会引起回流——改变了布局
- 避免使用table布局，可能很小的一个改动就会造成整个table的重新布局
- 尽可能再dom树的最末端改变class，回流是不可避免的，但可以减少影响
- 避免设置多层内联样式，css选择器从右往左匹配查找，避免节点层级过多
- 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流
- 避免使用CSS表达式，可能会引发回流

2. javascript
- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。