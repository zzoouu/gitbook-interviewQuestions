### 浏览器进程、浏览器内核、js引擎单线程、js时间循环机制
#### 区分进程和线程
- 系统为进程分配内存资源（独立的一块内存），进程之间相互独立
- 一个进程由一个或多个线程组成，多个线程在进程中协作完成任务
- 同一进程的多个线程共享程序的内存空间（包括代码段、数据集、堆）
> 官方
- 进程是cpu分配资源的最小单位（能拥有资源和独立运行的最小单位）
- 线程是cpu能调度的最小单位（线程是建立在进程之上的一次程序运行单位，一个进程中可以有多个线程）
> tip
- 不同进程之间也可以通信，代价较大
- 单线程和多线程（指一个进程中的单和多）

#### 浏览器多进程
- 浏览器是多进程的
- 浏览器的运行，是因为系统给他的进程分配了资源（CPU、内存)
- 简单的理解为浏览器每打开一个tab页，相当于创建了一个独立的浏览器进程
*有时候浏览器打开多个tab页面时，有些进程被合并了，所以每一个tab页面对应一个进程不一定是绝对的*

#### 浏览器进程
1. Browser进程：浏览器的主进程（负责协调、主控），只有一个
- 负责浏览器界面显示，与用户交互。如前进，后退等
- 负责各个页面的管理，创建和销毁其他进程
- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
- 网络资源的管理，下载等

2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

3. GPU进程：最多一个，用于3D绘制等

4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响
- 页面渲染，脚本执行，事件处理等

#### 浏览器内核（渲染进程）
> 渲染进程是多线程的: GUI渲染线程、JS引擎线程、事件触发线程、定时触发器线程、异步http请求线程
1. GUI渲染线程
- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行
2. JS引擎线程
- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
- JS引擎线程负责解析Javascript脚本，运行代码。
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
- 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
3. 事件触发线程
- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
4. 定时触发器线程
- 传说中的setInterval与setTimeout所在线程
- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. 异步http请求线程
- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

#### 浏览器渲染流程
1. 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程
2. 浏览器渲染流程开始
- 解析html建立dom树
- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
- 绘制render树（paint），绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
 
> css加载是否会阻塞dom树渲染？
- css是由单独的下载线程异步下载的。
- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）,但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

#### eventloop
- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

> 宏任务和微任务
1. macrotask（又称之为宏任务）
- 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
- 每一个task会从头到尾将这个任务执行完毕，不会执行其它
- 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染
（task->渲染->task->...）
2. microtask（又称为微任务）
- 可以理解是在当前 task 执行结束后立即执行的任务
- 也就是说，在当前task任务后，下一个task之前，在渲染之前
- 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
- 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

> macrotask：主代码块，setTimeout，setInterval,ajax等（可以看到，事件队列中的每一个事件都是一个macrotask)
> microtask：Promise，process.nextTick等

> 运行机制
- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

#### js异步
callback -> promise -> generator -> async/await
1. callback
> 函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。
时间延迟操作(seTimeout,setInterval),nodeapi,ajax  
```
fs.readFile(A, 'utf-8', function(err, data) {
    fs.readFile(B, 'utf-8', function(err, data) {
        fs.readFile(C, 'utf-8', function(err, data) {
            fs.readFile(D, 'utf-8', function(err, data) {
                //....
            });
        });
    });
});
```
好处: 用回调函数的方法来进行异步开发好处就是简单明了，容易理解
缺点： 稍微复杂的操作，程序就显得异常复杂，代码难以理解和调试，这种就是我们常说的回调地狱，不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪

2. 事件监听
> 此时，异步函数的执行，不取决于代码的顺序，而是取决于某个事件是否发生
f1发生done事件时，出发f2事件
```
f1.on('done',f2)
```
f1执行完之后，立刻触发done时间内，然后执行f2事件
```
funtion f1(){
    setTimeout(() => {
        ...
        f1.trigger('done')
    },1000)
}
```

优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合，利于实现模块化
缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程

3. 发布订阅
假定存在一个信号中心，某个任务执行完成，就像任务中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe)这个信号，从而可以知道自己什么时候可以开始执行，这就叫做“发布/订阅”模式（publish-subscribe pattern），又叫观察者模式（observer pattern）
首先,f2先向信号中心订阅done信号
```
jQuery.subscribe('done',f2)
```

f1发布信号
```
function f1(){
    setTimeout(() => {
        ...
        jQuery.publish('done')
    },1000)
}
```
取消订阅
```
jQuery.unsubscribe('done',f2)
```
> 这种方法的性质与“事件监听”类似，但比事件监听好，可以知道有多少信号，每个信号有多少订阅者，从而监控程序的运行

4. Promise
promise三种状态：
Pending--Promise实例对象创建时候的初始状态
Resolve--成功的状态
Rejected--失败的状态

> 状态一旦更改，不能再更改状态
```
let p = new Promise((resolve, reject) => {
    reject('reject')
    resolve('success') // 无效代码，不会执行
})
p.then(
    value => console.log(value),
    reason => console.log(reason) //reject
)
```

- 每次调用，都返回一个新的promise实例
- 如果then中返回的是一个结果的话，会把这个结果传递给下一次then中的回调
- 如果then中出现异常，会走下一个then中的失败回调
- 如果在then中使用了return，那么return的值会被Promise.resolve()包装
- then中可以不传递参数，如果不传递会透到下一个then中(见例3)
- catch 会捕获到没有捕获的异常

优点：
    1. 一旦状态改变，就不会再变，任何时候都可以得到这个结果
    2. 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
缺点： 
    1. 无法取消 Promise
    2. 当处于pending状态时，无法得知目前进展到哪一个阶段
    3. 错误不能被 try catch

5. Generator/yield
- 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
- Generator 函数除了状态机，还是一个遍历器对象生成函数。
- 可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。
- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值
```
function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}
```

6. async/await
> 代码清晰，不用像 Promise 写很多 then 链，就可以处理回调地狱的问题。并且错误可以被try catch,使得异步代码看起来像同步代码
```
const fs = require('fs');
const bluebird = require('bluebird');
const readFile = bluebird.promisify(fs.readFile);


async function read() {
    await readFile(A, 'utf-8');
    await readFile(B, 'utf-8');
    await readFile(C, 'utf-8');
    //code
}

read().then((data) => {
    //code
}).catch(err => {
    //code
});
```

https://juejin.im/post/5a6547d0f265da3e283a1df7
